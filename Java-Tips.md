1. ```Java```集合—```HashMap```

   1. 特点：基于Map接口的实现，存储键值对，允许null键值，是非同步的，不保证有序，也不保证时序不随时间变化，HashMap存储着Entry(hash、key、value、next)对象

   2. 实现原理：

      ```java
      1.HashMap底层是由数组加链表结构实现的。数组用来存放元素位置，链表用来解决hash冲突。当往HashMap中添加对象时，先计算key的hashCode，然后根据hashCode计算出元素应该放到数组的哪个位置。找到相应的位置，判断该位置是否已经存在键值对，如果已存在，那么覆盖掉原来的value，如果不存在，就放到该位置。链表的存在就是为了解决不同key出现hash冲突的问题，一般元素会放在链表头，这样做减少操作。
      2.两个重要参数：容量(capacity)和负载因子(load factor)
        //初始容量，即最开始线性表的大小为16
        DEFAULT_INITIAL_CAPACITY = 1<<4
        //初始的负载因子
        DEFAULT_LOAD_FACTOR = 0.75
        当线性表中的元素（这里指的是HashMap中元素的总个数）>初始容量*负载因子时，线性表会进行扩容操作，将数组长度变为原来的2倍，然后将元素重新计算hashCode放到相应位置（为什么要重新计算hashCode？：虽然key的hashCode不变，但是数组长度变了，在根据hashCode计算数组位置时，得出的索引值肯定是不同的，如果平移过来，会直接导致扩容前添加到HashMap中的数据无法被get到，因为在数组中索引变了）。
      ```

   3. 非同步导致线程不安全：在多线程操作情况下什么时候线程不安全？

      ```java
      1.如果在多个线程，在某一时刻同时操作HashMap并执行put操作。可能会有大于两个key的hash值相同，这个时候需要解决碰撞冲突
      2.put方法不是同步的，同时调用了addEntry方法，addEntry方法依然不是同步的
      3.HashMap存在扩容现象，扩容方法也不是同步的
      解决：使用Collections.synchronizedMap(new HashMap(...))
      ```

   4. ```TreeMap```和```LinkedHashMap```

      ```TreeMap```实现了```SortedMap```接口，对插入的记录根据key排序，默认按照升序排序

      ```LinkedHashMap```是Hash表和链表的实现，并且依靠双向链表保证了迭代顺序是插入的顺序

   5. ```ConcurrentHashMap```和```HashTable```

      1.```HashTable```是线程安全的，它使用```synchronized```来做线程安全，全局只有一把锁

      2.```ConcurrentHashMap```引入了分段锁的技术，即把一个大的Map拆分成N个小的```HashTable```

2. Socket

3. TCP/IP协议

   ```java
   1.三次握手
     第一次握手：建立连接，客户端发送连接请求报文段，将SYN位置为1，并置发送序号为X，然后客户端进入SYN_SEND状态，等待服务器的确认
     第二次握手：服务端发送SYN+ACK报文，并置发送序号为Y，在确认序号为X+1，此时服务端进入SYN_RECV状态
     第三次握手：客户端收到服务端的SYN+ACK报文，发送ack报文，并置发送序号为Z，在确认序号为Y+1
     为什么要三次握手：防止已失效的连接请求报文段突然又传送到服务端，因而产生错误
   2.四次挥手
     1.主机1发送Fin+Ack报文，表示主动方没有数据要发送给主机2了
     2.主机2收到之后发送Ack报文，表示我同意你的关闭请求
     3.主机2向主机1发送FIN报文段，请求关闭连接
     4.主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入等待状态，主机2收到主机1的ACK报文之后就关闭连接，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
   ```

   

4. Http/Https

   ```java
   1.涉及的加密方式：对称加密和非对称加密
   2.请求流程
   ```

   

